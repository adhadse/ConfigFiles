import { Signal } from '@lumino/signaling';
import { AskServersToSendTraceNotifications } from './_plugin';
import type * as ConnectionModuleType from './connection';
import { ClientCapabilities } from './lsp';
import { ILSPLogConsole, ILanguageServerManager, TLanguageServerConfigurations } from './tokens';
import { IForeignContext, VirtualDocument } from './virtual/document';
export interface IDocumentConnectionData {
    virtual_document: VirtualDocument;
    connection: ConnectionModuleType.LSPConnection;
}
export interface ISocketConnectionOptions {
    virtual_document: VirtualDocument;
    /**
     * The language identifier, corresponding to the API endpoint on the LSP proxy server.
     */
    language: string;
    /**
     * Path to the document in the JupyterLab space
     */
    document_path: string;
    /**
     * LSP capabilities describing currently supported features
     */
    capabilities: ClientCapabilities;
}
/**
 * Each Widget with a document (whether file or a notebook) has the same DocumentConnectionManager
 * (see JupyterLabWidgetAdapter). Using id_path instead of uri led to documents being overwritten
 * as two identical id_paths could be created for two different notebooks.
 */
export declare class DocumentConnectionManager {
    connections: Map<VirtualDocument.uri, ConnectionModuleType.LSPConnection>;
    documents: Map<VirtualDocument.uri, VirtualDocument>;
    initialized: Signal<DocumentConnectionManager, IDocumentConnectionData>;
    connected: Signal<DocumentConnectionManager, IDocumentConnectionData>;
    /**
     * Connection temporarily lost or could not be fully established; a re-connection will be attempted;
     */
    disconnected: Signal<DocumentConnectionManager, IDocumentConnectionData>;
    /**
     * Connection was closed permanently and no-reconnection will be attempted, e.g.:
     *  - there was a serious server error
     *  - user closed the connection,
     *  - re-connection attempts exceeded,
     */
    closed: Signal<DocumentConnectionManager, IDocumentConnectionData>;
    documents_changed: Signal<DocumentConnectionManager, Map<VirtualDocument.uri, VirtualDocument>>;
    language_server_manager: ILanguageServerManager;
    initial_configurations: TLanguageServerConfigurations;
    private ignored_languages;
    private readonly console;
    constructor(options: DocumentConnectionManager.IOptions);
    connect_document_signals(virtual_document: VirtualDocument): void;
    disconnect_document_signals(virtual_document: VirtualDocument, emit?: boolean): void;
    on_foreign_document_opened(_host: VirtualDocument, context: IForeignContext): void;
    on_foreign_document_closed(_host: VirtualDocument, context: IForeignContext): void;
    private connect_socket;
    /**
     * Handles the settings that do not require an existing connection
     * with a language server (or can influence to which server the
     * connection will be created, e.g. `priority`).
     *
     * This function should be called **before** initialization of servers.
     */
    updateConfiguration(allServerSettings: TLanguageServerConfigurations): void;
    /**
     * Handles the settings that the language servers accept using
     * `onDidChangeConfiguration` messages, which should be passed under
     * the "serverSettings" keyword in the setting registry.
     * Other configuration options are handled by `updateConfiguration` instead.
     *
     * This function should be called **after** initialization of servers.
     */
    updateServerConfigurations(allServerSettings: TLanguageServerConfigurations): void;
    /**
     * Fired the first time a connection is opened. These _should_ be the only
     * invocation of `.on` (once remaining LSPFeature.connection_handlers are made
     * singletons).
     */
    on_new_connection: (connection: ConnectionModuleType.LSPConnection) => void;
    private forEachDocumentOfConnection;
    /**
     * TODO: presently no longer referenced. A failing connection would close
     * the socket, triggering the language server on the other end to exit
     */
    retry_to_connect(options: ISocketConnectionOptions, reconnect_delay: number, retrials_left?: number): Promise<void>;
    connect(options: ISocketConnectionOptions, firstTimeoutSeconds?: number, secondTimeoutMinutes?: number): Promise<ConnectionModuleType.LSPConnection | undefined>;
    unregister_document(virtual_document: VirtualDocument): void;
    updateLogging(logAllCommunication: boolean, setTrace: AskServersToSendTraceNotifications): void;
}
export declare namespace DocumentConnectionManager {
    interface IOptions {
        language_server_manager: ILanguageServerManager;
        console: ILSPLogConsole;
    }
    function solve_uris(virtual_document: VirtualDocument, language: string): IURIs;
    interface IURIs {
        base: string;
        document: string;
        server: string;
        socket: string;
    }
}
