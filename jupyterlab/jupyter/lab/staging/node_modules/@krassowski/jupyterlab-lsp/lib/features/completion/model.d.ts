import { CompleterModel, CompletionHandler } from '@jupyterlab/completer';
import { LazyCompletionItem } from './item';
interface ICompletionMatch<T extends CompletionHandler.ICompletionItem> {
    /**
     * A score which indicates the strength of the match.
     *
     * A lower score is better. Zero is the best possible score.
     */
    score: number;
    item: T;
}
/**
 * This will be contributed upstream
 */
export declare class GenericCompleterModel<T extends CompletionHandler.ICompletionItem> extends CompleterModel {
    settings: GenericCompleterModel.IOptions;
    constructor(settings?: GenericCompleterModel.IOptions);
    completionItems(): T[];
    setCompletionItems(newValue: T[]): void;
    private _markFragment;
    protected getFilterText(item: T): string;
    protected getHighlightableLabelRegion(item: T): string;
    private _sortAndFilter;
    protected compareMatches(a: ICompletionMatch<T>, b: ICompletionMatch<T>): number;
}
export declare namespace GenericCompleterModel {
    interface IOptions {
        /**
         * Whether matching should be case-sensitive (default = true)
         */
        caseSensitive?: boolean;
        /**
         * Whether perfect matches should be included (default = true)
         */
        includePerfectMatches?: boolean;
        /**
         * Wheteher matches should be pre-filtered (default = true)
         */
        preFilterMatches?: boolean;
    }
    const defaultOptions: IOptions;
}
export declare class LSPCompleterModel extends GenericCompleterModel<LazyCompletionItem> {
    protected getFilterText(item: LazyCompletionItem): string;
    protected compareMatches(a: ICompletionMatch<LazyCompletionItem>, b: ICompletionMatch<LazyCompletionItem>): number;
}
export {};
