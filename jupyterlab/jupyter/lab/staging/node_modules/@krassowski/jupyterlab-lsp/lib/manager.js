import { PageConfig, URLExt } from '@jupyterlab/coreutils';
import { ServerConnection } from '@jupyterlab/services';
import { Signal } from '@lumino/signaling';
import { ILanguageServerManager } from './tokens';
export class LanguageServerManager {
    constructor(options) {
        this._sessionsChanged = new Signal(this);
        this._sessions = new Map();
        this._specs = new Map();
        this._warningsEmitted = new Set();
        this._settings = options.settings || ServerConnection.makeSettings();
        this._baseUrl = options.baseUrl || PageConfig.getBaseUrl();
        this._retries = options.retries || 2;
        this._retriesInterval = options.retriesInterval || 10000;
        this._statusCode = -1;
        this._configuration = {};
        this.console = options.console;
        this.fetchSessions().catch(console.warn);
    }
    get specs() {
        return this._specs;
    }
    get statusUrl() {
        return URLExt.join(this._baseUrl, ILanguageServerManager.URL_NS, 'status');
    }
    get sessionsChanged() {
        return this._sessionsChanged;
    }
    get sessions() {
        return this._sessions;
    }
    setConfiguration(configuration) {
        this._configuration = configuration;
    }
    warnOnce(arg) {
        if (!this._warningsEmitted.has(arg)) {
            this._warningsEmitted.add(arg);
            this.console.warn(arg);
        }
    }
    _comparePriorities(a, b) {
        var _a, _b, _c, _d;
        const DEFAULT_PRIORITY = 50;
        const a_priority = (_b = (_a = this._configuration[a]) === null || _a === void 0 ? void 0 : _a.priority) !== null && _b !== void 0 ? _b : DEFAULT_PRIORITY;
        const b_priority = (_d = (_c = this._configuration[b]) === null || _c === void 0 ? void 0 : _c.priority) !== null && _d !== void 0 ? _d : DEFAULT_PRIORITY;
        if (a_priority == b_priority) {
            this.warnOnce(`Two matching servers: ${a} and ${b} have the same priority; choose which one to use by changing the priority in Advanced Settings Editor`);
            return a.localeCompare(b);
        }
        // higher priority = higher in the list (descending order)
        return b_priority - a_priority;
    }
    isMatchingSpec(options, spec) {
        // most things speak language
        // if language is not known, it is guessed based on MIME type earlier
        // so some language should be available by now (which can be not so obvious, e.g. "plain" for txt documents)
        const lowerCaseLanguage = options.language.toLocaleLowerCase();
        return spec.languages.some(language => language.toLocaleLowerCase() == lowerCaseLanguage);
    }
    getMatchingServers(options) {
        if (!options.language) {
            this.console.error('Cannot match server by language: language not available; ensure that kernel and specs provide language and MIME type');
            return [];
        }
        const matchingSessionsKeys = [];
        for (const [key, session] of this._sessions.entries()) {
            if (this.isMatchingSpec(options, session.spec)) {
                matchingSessionsKeys.push(key);
            }
        }
        return matchingSessionsKeys.sort(this._comparePriorities.bind(this));
    }
    getMatchingSpecs(options) {
        const result = new Map();
        for (const [key, specification] of this._specs.entries()) {
            if (this.isMatchingSpec(options, specification)) {
                result.set(key, specification);
            }
        }
        return result;
    }
    get statusCode() {
        return this._statusCode;
    }
    async fetchSessions() {
        let response = await ServerConnection.makeRequest(this.statusUrl, { method: 'GET' }, this._settings);
        this._statusCode = response.status;
        if (!response.ok) {
            console.error('Could not fetch sessions', response);
            if (this._retries > 0) {
                this._retries -= 1;
                setTimeout(this.fetchSessions.bind(this), this._retriesInterval);
            }
            return;
        }
        let sessions;
        try {
            const data = await response.json();
            sessions = data.sessions;
            try {
                this._version = data.version;
                this._specs = new Map(Object.entries(data.specs));
            }
            catch (err) {
                console.warn(err);
            }
        }
        catch (err) {
            console.warn(err);
            return;
        }
        for (let key of Object.keys(sessions)) {
            let id = key;
            if (this._sessions.has(id)) {
                Object.assign(this._sessions.get(id), sessions[key]);
            }
            else {
                this._sessions.set(id, sessions[key]);
            }
        }
        const oldKeys = this._sessions.keys();
        for (const oldKey in oldKeys) {
            if (!sessions[oldKey]) {
                let oldId = oldKey;
                this._sessions.delete(oldId);
            }
        }
        this._sessionsChanged.emit(void 0);
    }
}
//# sourceMappingURL=manager.js.map