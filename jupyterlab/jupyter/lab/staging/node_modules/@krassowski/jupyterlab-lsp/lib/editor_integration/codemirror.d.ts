import { CodeEditor } from '@jupyterlab/codeeditor';
import { IDocumentWidget } from '@jupyterlab/docregistry';
import { TranslationBundle } from '@jupyterlab/translation';
import type * as CodeMirror from 'codemirror';
import type * as lsProtocol from 'vscode-languageserver-protocol';
import { StatusMessage, WidgetAdapter } from '../adapters/adapter';
import { LSPConnection } from '../connection';
import { IEditorIntegrationOptions, IFeature, IFeatureEditorIntegration, IFeatureSettings } from '../feature';
import { IEditorPosition, IRootPosition, IVirtualPosition } from '../positioning';
import { ILSPLogConsole } from '../tokens';
import { CodeMirrorHandler, CodeMirrorVirtualEditor, EventName as CodeMirrorEventName } from '../virtual/codemirror_editor';
import { VirtualDocument } from '../virtual/document';
import { IEditorChange } from '../virtual/editor';
export interface IEditorRange {
    start: IEditorPosition;
    end: IEditorPosition;
    editor: CodeMirror.Editor;
}
export interface IEditOutcome {
    appliedChanges: number | null;
    modifiedCells: number;
    wasGranular: boolean;
    errors: string[];
}
/**
 * Interface for storage of HTMLElement event specifications (event name + handler).
 */
interface IHTMLEventMap<T extends keyof HTMLElementEventMap = keyof HTMLElementEventMap> extends Map<T, (event: HTMLElementEventMap[T]) => void> {
    set<E extends T>(k: E, handler: (event: HTMLElementEventMap[E]) => void): this;
    get<E extends T>(k: E): (event: HTMLElementEventMap[E]) => void;
}
/**
 * One feature of each type exists per VirtualDocument
 * (the initialization is performed by the adapter).
 */
export declare abstract class CodeMirrorIntegration implements IFeatureEditorIntegration<CodeMirrorVirtualEditor> {
    is_registered: boolean;
    feature: IFeature;
    protected readonly editor_handlers: Map<CodeMirrorEventName, CodeMirrorHandler>;
    protected readonly connection_handlers: Map<string, (response: Record<string, any>) => void>;
    protected readonly wrapper_handlers: IHTMLEventMap;
    protected wrapper: HTMLElement;
    protected virtual_editor: CodeMirrorVirtualEditor;
    protected virtual_document: VirtualDocument;
    protected connection: LSPConnection;
    protected status_message: StatusMessage;
    protected adapter: WidgetAdapter<IDocumentWidget>;
    protected console: ILSPLogConsole;
    protected trans: TranslationBundle;
    get settings(): IFeatureSettings<any> | undefined;
    get lab_integration(): import("../feature").IFeatureLabIntegration | undefined;
    constructor(options: IEditorIntegrationOptions);
    register(): void;
    remove(): void;
    protected range_to_editor_range(range: lsProtocol.Range, cm_editor?: CodeMirror.Editor): IEditorRange;
    protected position_from_mouse(event: MouseEvent): IRootPosition | null;
    transform_virtual_position_to_root_position(start: IVirtualPosition): IRootPosition;
    protected get_cm_editor(position: IRootPosition): CodeMirror.Editor;
    protected get_language_at(position: IEditorPosition, editor: CodeMirror.Editor): string | undefined;
    protected extract_last_character(change: CodeMirror.EditorChange): string;
    protected highlight_range(range: IEditorRange, class_name: string): CodeMirror.TextMarker;
    /**
     * Does the edit cover the entire document?
     */
    protected is_whole_document_edit(edit: lsProtocol.TextEdit): boolean;
    protected apply_edit(workspaceEdit: lsProtocol.WorkspaceEdit): Promise<IEditOutcome>;
    protected replace_fragment(newText: string, editor: CodeEditor.IEditor, fragment_start: CodeMirror.Position, fragment_end: CodeMirror.Position, start: CodeMirror.Position, end: CodeMirror.Position, is_whole_document_edit?: boolean): number;
    afterChange(change: IEditorChange, root_position: IRootPosition): void;
    protected apply_single_edit(edit: lsProtocol.TextEdit): number;
}
export declare type CodeMirrorIntegrationConstructor = {
    new (options: IEditorIntegrationOptions): CodeMirrorIntegration;
};
export {};
