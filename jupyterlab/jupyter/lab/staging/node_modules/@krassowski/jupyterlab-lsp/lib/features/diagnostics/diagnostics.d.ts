import { JupyterFrontEnd } from '@jupyterlab/application';
import { MainAreaWidget } from '@jupyterlab/apputils';
import { TranslationBundle } from '@jupyterlab/translation';
import { LabIcon } from '@jupyterlab/ui-components';
import type * as lsProtocol from 'vscode-languageserver-protocol';
import { CodeDiagnostics as LSPDiagnosticsSettings } from '../../_diagnostics';
import { LSPConnection } from '../../connection';
import { CodeMirrorIntegration } from '../../editor_integration/codemirror';
import { FeatureSettings } from '../../feature';
import { CodeMirrorVirtualEditor } from '../../virtual/codemirror_editor';
import { VirtualDocument } from '../../virtual/document';
import { DiagnosticsDatabase, DiagnosticsListing } from './listing';
export declare const diagnosticsIcon: LabIcon;
declare class DiagnosticsPanel {
    private _content;
    private _widget;
    feature: DiagnosticsCM;
    is_registered: boolean;
    trans: TranslationBundle;
    constructor(trans: TranslationBundle);
    get widget(): MainAreaWidget<DiagnosticsListing>;
    get content(): DiagnosticsListing;
    protected initWidget(): MainAreaWidget<DiagnosticsListing>;
    update(): void;
    register(app: JupyterFrontEnd): void;
}
export declare const diagnostics_panel: DiagnosticsPanel;
export declare const diagnostics_databases: WeakMap<CodeMirrorVirtualEditor, DiagnosticsDatabase>;
export declare class DiagnosticsCM extends CodeMirrorIntegration {
    private last_response;
    get settings(): FeatureSettings<LSPDiagnosticsSettings>;
    register(): void;
    clearDocumentDiagnostics(document: VirtualDocument): void;
    private unique_editor_ids;
    private marked_diagnostics;
    /**
     * Allows access to the most recent diagnostics in context of the editor.
     *
     * One can use VirtualEditorForNotebook.find_cell_by_editor() to find
     * the corresponding cell in notebook.
     * Can be used to implement a Panel showing diagnostics list.
     *
     * Maps virtual_document.uri to IEditorDiagnostic[].
     */
    get diagnostics_db(): DiagnosticsDatabase;
    switchDiagnosticsPanelSource: () => void;
    protected collapseOverlappingDiagnostics(diagnostics: lsProtocol.Diagnostic[]): Map<lsProtocol.Range, lsProtocol.Diagnostic[]>;
    get defaultSeverity(): lsProtocol.DiagnosticSeverity;
    private filterDiagnostics;
    setDiagnostics(response: lsProtocol.PublishDiagnosticsParams): void;
    handleDiagnostic: (connection: LSPConnection, response: lsProtocol.PublishDiagnosticsParams) => void;
    refreshDiagnostics(): void;
    protected removeUnusedDiagnosticMarkers(to_retain: Set<string>): void;
    remove(): void;
}
export {};
