import { ISignal, Signal } from '@lumino/signaling';
import { AnyCompletion, AnyLocation, IDocumentInfo, ILspOptions, IPosition, LspWsConnection } from 'lsp-ws-connection';
import type * as rpc from 'vscode-jsonrpc';
import type * as lsp from 'vscode-languageserver-protocol';
import { ClientCapabilities } from './lsp';
import { ILSPLogConsole } from './tokens';
interface ILSPOptions extends ILspOptions {
    capabilities: ClientCapabilities;
    serverIdentifier?: string;
    console: ILSPLogConsole;
}
/**
 * Method strings are reproduced here because a non-typing import of
 * `vscode-languageserver-protocol` is ridiculously expensive.
 */
export declare namespace Method {
    /** Server notifications */
    enum ServerNotification {
        PUBLISH_DIAGNOSTICS = "textDocument/publishDiagnostics",
        SHOW_MESSAGE = "window/showMessage",
        LOG_TRACE = "$/logTrace",
        LOG_MESSAGE = "window/logMessage"
    }
    /** Client notifications */
    enum ClientNotification {
        DID_CHANGE = "textDocument/didChange",
        DID_CHANGE_CONFIGURATION = "workspace/didChangeConfiguration",
        DID_OPEN = "textDocument/didOpen",
        DID_SAVE = "textDocument/didSave",
        INITIALIZED = "initialized",
        SET_TRACE = "$/setTrace"
    }
    /** Server requests */
    enum ServerRequest {
        REGISTER_CAPABILITY = "client/registerCapability",
        SHOW_MESSAGE_REQUEST = "window/showMessageRequest",
        UNREGISTER_CAPABILITY = "client/unregisterCapability",
        WORKSPACE_CONFIGURATION = "workspace/configuration"
    }
    /** Client requests */
    enum ClientRequest {
        COMPLETION = "textDocument/completion",
        COMPLETION_ITEM_RESOLVE = "completionItem/resolve",
        DEFINITION = "textDocument/definition",
        DOCUMENT_HIGHLIGHT = "textDocument/documentHighlight",
        DOCUMENT_SYMBOL = "textDocument/documentSymbol",
        HOVER = "textDocument/hover",
        IMPLEMENTATION = "textDocument/implementation",
        INITIALIZE = "initialize",
        REFERENCES = "textDocument/references",
        RENAME = "textDocument/rename",
        SIGNATURE_HELP = "textDocument/signatureHelp",
        TYPE_DEFINITION = "textDocument/typeDefinition"
    }
}
export interface IServerNotifyParams {
    [Method.ServerNotification.LOG_MESSAGE]: lsp.LogMessageParams;
    [Method.ServerNotification.LOG_TRACE]: rpc.LogTraceParams;
    [Method.ServerNotification.PUBLISH_DIAGNOSTICS]: lsp.PublishDiagnosticsParams;
    [Method.ServerNotification.SHOW_MESSAGE]: lsp.ShowMessageParams;
}
export interface IClientNotifyParams {
    [Method.ClientNotification
        .DID_CHANGE_CONFIGURATION]: lsp.DidChangeConfigurationParams;
    [Method.ClientNotification.DID_CHANGE]: lsp.DidChangeTextDocumentParams;
    [Method.ClientNotification.DID_OPEN]: lsp.DidOpenTextDocumentParams;
    [Method.ClientNotification.DID_SAVE]: lsp.DidSaveTextDocumentParams;
    [Method.ClientNotification.INITIALIZED]: lsp.InitializedParams;
    [Method.ClientNotification.SET_TRACE]: rpc.SetTraceParams;
}
export interface IServerRequestParams {
    [Method.ServerRequest.REGISTER_CAPABILITY]: lsp.RegistrationParams;
    [Method.ServerRequest.SHOW_MESSAGE_REQUEST]: lsp.ShowMessageRequestParams;
    [Method.ServerRequest.UNREGISTER_CAPABILITY]: lsp.UnregistrationParams;
    [Method.ServerRequest.WORKSPACE_CONFIGURATION]: lsp.ConfigurationParams;
}
export interface IServerResult {
    [Method.ServerRequest.REGISTER_CAPABILITY]: void;
    [Method.ServerRequest.SHOW_MESSAGE_REQUEST]: lsp.MessageActionItem | null;
    [Method.ServerRequest.UNREGISTER_CAPABILITY]: void;
    [Method.ServerRequest.WORKSPACE_CONFIGURATION]: any[];
}
export interface IClientRequestParams {
    [Method.ClientRequest.COMPLETION_ITEM_RESOLVE]: lsp.CompletionItem;
    [Method.ClientRequest.COMPLETION]: lsp.CompletionParams;
    [Method.ClientRequest.DEFINITION]: lsp.TextDocumentPositionParams;
    [Method.ClientRequest.DOCUMENT_HIGHLIGHT]: lsp.TextDocumentPositionParams;
    [Method.ClientRequest.DOCUMENT_SYMBOL]: lsp.DocumentSymbolParams;
    [Method.ClientRequest.HOVER]: lsp.TextDocumentPositionParams;
    [Method.ClientRequest.IMPLEMENTATION]: lsp.TextDocumentPositionParams;
    [Method.ClientRequest.INITIALIZE]: lsp.InitializeParams;
    [Method.ClientRequest.REFERENCES]: lsp.ReferenceParams;
    [Method.ClientRequest.RENAME]: lsp.RenameParams;
    [Method.ClientRequest.SIGNATURE_HELP]: lsp.TextDocumentPositionParams;
    [Method.ClientRequest.TYPE_DEFINITION]: lsp.TextDocumentPositionParams;
}
export interface IClientResult {
    [Method.ClientRequest.COMPLETION_ITEM_RESOLVE]: lsp.CompletionItem;
    [Method.ClientRequest.COMPLETION]: AnyCompletion;
    [Method.ClientRequest.DEFINITION]: AnyLocation;
    [Method.ClientRequest.DOCUMENT_HIGHLIGHT]: lsp.DocumentHighlight[];
    [Method.ClientRequest.DOCUMENT_SYMBOL]: lsp.DocumentSymbol[];
    [Method.ClientRequest.HOVER]: lsp.Hover;
    [Method.ClientRequest.IMPLEMENTATION]: AnyLocation;
    [Method.ClientRequest.INITIALIZE]: lsp.InitializeResult;
    [Method.ClientRequest.REFERENCES]: Location[];
    [Method.ClientRequest.RENAME]: lsp.WorkspaceEdit;
    [Method.ClientRequest.SIGNATURE_HELP]: lsp.SignatureHelp;
    [Method.ClientRequest.TYPE_DEFINITION]: AnyLocation;
}
export declare type ServerNotifications<T extends keyof IServerNotifyParams = keyof IServerNotifyParams> = {
    readonly [key in T]: ISignal<LSPConnection, IServerNotifyParams[key]>;
};
export declare type ClientNotifications<T extends keyof IClientNotifyParams = keyof IClientNotifyParams> = {
    readonly [key in T]: Signal<LSPConnection, IClientNotifyParams[key]>;
};
export interface IClientRequestHandler<T extends keyof IClientRequestParams = keyof IClientRequestParams> {
    request(params: IClientRequestParams[T]): Promise<IClientResult[T]>;
}
export interface IServerRequestHandler<T extends keyof IServerRequestParams = keyof IServerRequestParams> {
    setHandler(handler: (params: IServerRequestParams[T], connection?: LSPConnection) => Promise<IServerResult[T]>): void;
    clearHandler(): void;
}
export declare type ClientRequests<T extends keyof IClientRequestParams = keyof IClientRequestParams> = {
    readonly [key in T]: IClientRequestHandler<key>;
};
export declare type ServerRequests<T extends keyof IServerRequestParams = keyof IServerRequestParams> = {
    readonly [key in T]: IServerRequestHandler<key>;
};
export declare const Provider: {
    [key: string]: keyof lsp.ServerCapabilities;
};
declare type AnyMethod = Method.ServerNotification | Method.ClientNotification | Method.ClientRequest | Method.ServerRequest;
declare enum MessageKind {
    client_notified_server = 0,
    server_notified_client = 1,
    server_requested = 2,
    client_requested = 3,
    result_for_client = 4,
    response_for_server = 5
}
interface IMessageLog<T extends AnyMethod = AnyMethod> {
    method: T;
    message: any;
}
export declare class LSPConnection extends LspWsConnection {
    protected documentsToOpen: IDocumentInfo[];
    serverIdentifier?: string;
    clientNotifications: ClientNotifications;
    serverNotifications: ServerNotifications;
    clientRequests: ClientRequests;
    serverRequests: ServerRequests;
    protected console: ILSPLogConsole;
    private _options;
    logAllCommunication: boolean;
    log(kind: MessageKind, message: IMessageLog): void;
    protected constructNotificationHandlers<T extends ServerNotifications | ClientNotifications>(methods: typeof Method.ServerNotification | typeof Method.ClientNotification): T;
    protected constructClientRequestHandler<T extends ClientRequests, U extends keyof T = keyof T>(methods: typeof Method.ClientRequest): T;
    protected constructServerRequestHandler<T extends ServerRequests, U extends keyof T = keyof T>(methods: typeof Method.ServerRequest): T;
    constructor(options: ILSPOptions);
    /**
     * Initialization parameters to be sent to the language server.
     * Subclasses can overload this when adding more features.
     */
    protected initializeParams(): lsp.InitializeParams;
    sendOpenWhenReady(documentInfo: IDocumentInfo): void;
    protected onServerInitialized(params: lsp.InitializeResult): void;
    protected afterInitialized(): void;
    sendSelectiveChange(changeEvent: lsp.TextDocumentContentChangeEvent, documentInfo: IDocumentInfo): void;
    sendFullTextChange(text: string, documentInfo: IDocumentInfo): void;
    /**
     * @deprecated The method should not be used in new code. Use provides() instead.
     */
    isRenameSupported(): boolean;
    provides(provider: keyof lsp.ServerCapabilities): boolean;
    /**
     * @deprecated The method should not be used in new code
     */
    rename(location: IPosition, documentInfo: IDocumentInfo, newName: string, emit?: boolean): Promise<lsp.WorkspaceEdit | null>;
    connect(socket: WebSocket): this;
    private closing_manually;
    close(): void;
    private _sendChange;
    getCompletionResolve(completionItem: lsp.CompletionItem): Promise<lsp.CompletionItem | undefined>;
    /**
     * Does support completionItem/resolve?
     * @deprecated The method should not be used in new code
     */
    isCompletionResolveProvider(): boolean;
}
export {};
