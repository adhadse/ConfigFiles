import { JupyterFrontEnd, JupyterFrontEndPlugin } from '@jupyterlab/application';
import { CodeEditor } from '@jupyterlab/codeeditor';
import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
import { LabIcon } from '@jupyterlab/ui-components';
import { Throttler } from '@lumino/polling';
import type * as CodeMirror from 'codemirror';
import type * as lsProtocol from 'vscode-languageserver-protocol';
import { CodeHover as LSPHoverSettings, ModifierKey } from '../_hover';
import { EditorTooltipManager } from '../components/free_tooltip';
import { CodeMirrorIntegration, IEditorRange } from '../editor_integration/codemirror';
import { FeatureSettings, IEditorIntegrationOptions, IFeatureLabIntegration } from '../feature';
import { IRootPosition, IVirtualPosition } from '../positioning';
import { VirtualDocument } from '../virtual/document';
import { IEditorChange } from '../virtual/editor';
export declare const hoverIcon: LabIcon;
interface IResponseData {
    response: lsProtocol.Hover;
    document: VirtualDocument;
    editor_range: IEditorRange;
    ce_editor: CodeEditor.IEditor;
}
declare class ResponseCache {
    maxSize: number;
    protected _data: Array<IResponseData>;
    get data(): IResponseData[];
    constructor(maxSize: number);
    store(item: IResponseData): void;
    clean(): void;
}
export declare class HoverCM extends CodeMirrorIntegration {
    protected last_hover_character: IRootPosition | null;
    private last_hover_response;
    protected hover_marker: CodeMirror.TextMarker | null;
    private virtual_position;
    protected cache: ResponseCache;
    private debounced_get_hover;
    private tooltip;
    private _previousHoverRequest;
    constructor(options: IEditorIntegrationOptions);
    protected get modifierKey(): ModifierKey;
    get lab_integration(): HoverLabIntegration;
    get settings(): FeatureSettings<LSPHoverSettings>;
    protected restore_from_cache(document: VirtualDocument, virtual_position: IVirtualPosition): IResponseData | null;
    register(): void;
    protected onKeyDown: (event: KeyboardEvent) => void;
    protected onMouseLeave: (event: MouseEvent) => void;
    protected maybeHideTooltip(mouseEvent: MouseEvent): void;
    protected create_throttler(): Throttler<Promise<lsProtocol.Hover | undefined>, any>;
    afterChange(change: IEditorChange, root_position: IRootPosition): void;
    protected on_hover: () => Promise<lsProtocol.Hover | undefined>;
    protected static get_markup_for_hover(response: lsProtocol.Hover): lsProtocol.MarkupContent;
    /**
     * Underlines the word if a tooltip is available.
     * Displays tooltip if asked to do so.
     *
     * Returns true is the tooltip was shown.
     */
    handleResponse: (response_data: IResponseData, root_position: IRootPosition, show_tooltip: boolean) => boolean;
    protected is_token_empty(token: CodeMirror.Token): boolean;
    protected is_event_inside_visible(event: MouseEvent): boolean;
    protected is_useful_response(response: lsProtocol.Hover): boolean | "";
    /**
     * Returns true if the tooltip should stay.
     */
    protected _updateUnderlineAndTooltip(event: MouseEvent): Promise<boolean>;
    protected updateUnderlineAndTooltip: (event: MouseEvent) => Promise<boolean> | undefined;
    protected remove_range_highlight: () => void;
    remove(): void;
    private get_editor_range;
    private add_range_if_needed;
}
declare class HoverLabIntegration implements IFeatureLabIntegration {
    tooltip: EditorTooltipManager;
    settings: FeatureSettings<any>;
    constructor(app: JupyterFrontEnd, settings: FeatureSettings<any>, renderMimeRegistry: IRenderMimeRegistry);
}
export declare const HOVER_PLUGIN: JupyterFrontEndPlugin<void>;
export {};
