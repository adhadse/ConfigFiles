import * as lsProtocol from 'vscode-languageserver-types';
import { until_ready } from '../../utils';
export class LazyCompletionItem {
    constructor(
    /**
     * Type of this completion item.
     */
    type, 
    /**
     * LabIcon object for icon to be rendered with completion type.
     */
    icon, match, connector, uri) {
        this.type = type;
        this.icon = icon;
        this.match = match;
        this.connector = connector;
        this.uri = uri;
        this.label = match.label;
        this._setDocumentation(match.documentation);
        this._requested_resolution = false;
        this._resolved = false;
        this._detail = match.detail;
        this.self = this;
    }
    get isDocumentationMarkdown() {
        return this._is_documentation_markdown;
    }
    _setDocumentation(documentation) {
        if (lsProtocol.MarkupContent.is(documentation)) {
            this._documentation = documentation.value;
            this._is_documentation_markdown = documentation.kind === 'markdown';
        }
        else {
            this._documentation = documentation;
            this._is_documentation_markdown = false;
        }
    }
    /**
     * Completion to be inserted.
     */
    get insertText() {
        return this._currentInsertText || this.match.insertText || this.match.label;
    }
    set insertText(text) {
        this._currentInsertText = text;
    }
    get sortText() {
        return this.match.sortText || this.match.label;
    }
    get filterText() {
        return this.match.filterText;
    }
    supportsResolution() {
        const connection = this.connector.get_connection(this.uri);
        return connection != null && connection.isCompletionResolveProvider();
    }
    get detail() {
        return this._detail;
    }
    needsResolution() {
        if (this.documentation) {
            return false;
        }
        if (this._resolved) {
            return false;
        }
        if (this._requested_resolution) {
            return false;
        }
        return this.supportsResolution();
    }
    isResolved() {
        return this._resolved;
    }
    /**
     * Resolve (fetch) details such as documentation.
     */
    resolve() {
        if (this._resolved) {
            return Promise.resolve(this);
        }
        if (!this.supportsResolution()) {
            return Promise.resolve(this);
        }
        if (this._requested_resolution) {
            return until_ready(() => this._resolved, 100, 50).then(() => this);
        }
        const connection = this.connector.get_connection(this.uri);
        this._requested_resolution = true;
        return connection
            .getCompletionResolve(this.match)
            .then(resolvedCompletionItem => {
            if (resolvedCompletionItem === null) {
                return resolvedCompletionItem;
            }
            this._setDocumentation(resolvedCompletionItem === null || resolvedCompletionItem === void 0 ? void 0 : resolvedCompletionItem.documentation);
            this._detail = resolvedCompletionItem === null || resolvedCompletionItem === void 0 ? void 0 : resolvedCompletionItem.detail;
            // TODO: implement in pyls and enable with proper LSP communication
            // this.label = resolvedCompletionItem.label;
            this._resolved = true;
            return this;
        });
    }
    /**
     * A human-readable string with additional information
     * about this item, like type or symbol information.
     */
    get documentation() {
        if (!this.connector.should_show_documentation) {
            return undefined;
        }
        if (this._documentation) {
            return this._documentation;
        }
        return undefined;
    }
    /**
     * Indicates if the item is deprecated.
     */
    get deprecated() {
        if (this.match.deprecated) {
            return this.match.deprecated;
        }
        return (this.match.tags != null &&
            this.match.tags.some(tag => tag == lsProtocol.CompletionItemTag.Deprecated));
    }
}
//# sourceMappingURL=item.js.map