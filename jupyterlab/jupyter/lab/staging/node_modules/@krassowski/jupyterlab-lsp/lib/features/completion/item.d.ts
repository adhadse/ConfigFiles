import { CompletionHandler } from '@jupyterlab/completer';
import { LabIcon } from '@jupyterlab/ui-components';
import * as lsProtocol from 'vscode-languageserver-types';
import { LSPConnector } from './completion_handler';
/**
 * To be upstreamed
 */
export interface ICompletionsSource {
    /**
     * The name displayed in the GUI
     */
    name: string;
    /**
     * The higher the number the higher the priority
     */
    priority: number;
    /**
     * The icon to be displayed if no type icon is present
     */
    fallbackIcon?: LabIcon;
}
/**
 * To be upstreamed
 */
export interface IExtendedCompletionItem extends CompletionHandler.ICompletionItem {
    insertText: string;
    sortText: string;
    source?: ICompletionsSource;
}
export declare class LazyCompletionItem implements IExtendedCompletionItem {
    /**
     * Type of this completion item.
     */
    type: string;
    /**
     * LabIcon object for icon to be rendered with completion type.
     */
    icon: LabIcon;
    private match;
    private connector;
    private uri;
    private _detail;
    private _documentation;
    private _is_documentation_markdown;
    private _requested_resolution;
    private _resolved;
    /**
     * Self-reference to make sure that the instance for will remain accessible
     * after any copy operation (whether via spread syntax or Object.assign)
     * performed by the JupyterLab completer internals.
     */
    self: LazyCompletionItem;
    element: HTMLLIElement;
    private _currentInsertText;
    get isDocumentationMarkdown(): boolean;
    /**
     * User facing completion.
     * If insertText is not set, this will be inserted.
     */
    label: string;
    source: ICompletionsSource;
    constructor(
    /**
     * Type of this completion item.
     */
    type: string, 
    /**
     * LabIcon object for icon to be rendered with completion type.
     */
    icon: LabIcon, match: lsProtocol.CompletionItem, connector: LSPConnector, uri: string);
    private _setDocumentation;
    /**
     * Completion to be inserted.
     */
    get insertText(): string;
    set insertText(text: string);
    get sortText(): string;
    get filterText(): string | undefined;
    supportsResolution(): boolean;
    get detail(): string | undefined;
    needsResolution(): boolean;
    isResolved(): boolean;
    /**
     * Resolve (fetch) details such as documentation.
     */
    resolve(): Promise<lsProtocol.CompletionItem>;
    /**
     * A human-readable string with additional information
     * about this item, like type or symbol information.
     */
    get documentation(): string | undefined;
    /**
     * Indicates if the item is deprecated.
     */
    get deprecated(): boolean;
}
