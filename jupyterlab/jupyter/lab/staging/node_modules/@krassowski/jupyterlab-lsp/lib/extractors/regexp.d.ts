import { replacer } from '../overrides/tokens';
import { IExtractedCode, IForeignCodeExtractor } from './types';
export declare function getIndexOfCaptureGroup(expression: RegExp, matched_string: string, value_of_captured_group: string): number;
export declare class RegExpForeignCodeExtractor implements IForeignCodeExtractor {
    options: RegExpForeignCodeExtractor.IOptions;
    language: string;
    global_expression: RegExp;
    test_expression: RegExp;
    expression: RegExp;
    standalone: boolean;
    file_extension: string;
    constructor(options: RegExpForeignCodeExtractor.IOptions);
    has_foreign_code(code: string): boolean;
    extract_foreign_code(code: string): IExtractedCode[];
}
declare namespace RegExpForeignCodeExtractor {
    interface IOptions {
        /**
         * The foreign language.
         */
        language: string;
        /**
         * String giving regular expression to test cells for the foreign language presence.
         *
         * For example:
         *   - `%%R( (.*))?\n(.*)` will match R cells of rpy2
         *   - `(.*)'<html>(.*)</html>'(.*)` will match html documents in strings of any language using single ticks
         */
        pattern: string;
        /**
         * Array of numbers specifying match groups to be extracted from the regular expression match,
         * for the use in virtual document of the foreign language.
         * For the R example this should be `3`. Please not that these are 1-based, as the 0th index is the full match.
         * If multiple groups are given, those will be concatenated.
         *
         * If additional code is needed in between the groups, use `foreign_replacer` in addition to
         * `foreign_capture_groups` (but not instead!).
         *
         * `foreign_capture_groups` is required for proper offset calculation and will no longer be optional in 4.0.
         */
        foreign_capture_groups?: number[];
        /**
         * Function to compose the foreign document code, in case if using a capture group alone is not sufficient;
         * If specified, `foreign_capture_group` should be specified as well, so that it points to the first occurrence
         * of the foreign code. When both are specified, `foreign_replacer` takes precedence.
         *
         * See:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter
         */
        foreign_replacer?: replacer;
        /**
         * @deprecated `extract_to_foreign` will be removed in 4.0; use `foreign_capture_group` or `foreign_replacer` instead
         */
        extract_to_foreign?: string | replacer;
        /**
         * If arguments from the cell or line magic are to be extracted and prepended before the extracted code,
         * set extract_arguments to a replacer function taking the code and returning the string to be prepended.
         */
        extract_arguments?: replacer;
        /**
         * Boolean if everything (true, default) or nothing (false) should be kept in the host document.
         *
         * For the R example this should be empty if we wish to ignore the cell,
         * but usually a better option is to retain the foreign code and use language
         * specific overrides to suppress the magic in a more controlled way, providing
         * dummy python code to handle cell input/output.
         *
         * Setting to false is DEPRECATED as it breaks the edit feature (while it could be fixed,
         * it would make the code considerably more complex).
         *
         * @deprecated `keep_in_host` will be removed in 4.0
         */
        keep_in_host?: boolean;
        /**
         * Should the foreign code be appended (False) to the previously established virtual document of the same language,
         * or is it standalone snippet which requires separate connection?
         */
        is_standalone: boolean;
        file_extension: string;
    }
}
export {};
