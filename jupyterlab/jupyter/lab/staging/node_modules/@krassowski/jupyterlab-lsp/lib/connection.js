// Disclaimer/acknowledgement: Fragments are based on LspWsConnection, which is copyright of wylieconlon and contributors and ISC licenced.
// ISC licence is, quote, "functionally equivalent to the simplified BSD and MIT licenses,
// but without language deemed unnecessary following the Berne Convention." (Wikipedia).
// Introduced modifications are BSD licenced, copyright JupyterLab development team.
import { Signal } from '@lumino/signaling';
import { LspWsConnection } from 'lsp-ws-connection';
import { registerServerCapability, unregisterServerCapability } from 'lsp-ws-connection/lib/server-capability-registration';
import { until_ready } from './utils';
/**
 * Method strings are reproduced here because a non-typing import of
 * `vscode-languageserver-protocol` is ridiculously expensive.
 */
export var Method;
(function (Method) {
    /** Server notifications */
    let ServerNotification;
    (function (ServerNotification) {
        ServerNotification["PUBLISH_DIAGNOSTICS"] = "textDocument/publishDiagnostics";
        ServerNotification["SHOW_MESSAGE"] = "window/showMessage";
        ServerNotification["LOG_TRACE"] = "$/logTrace";
        ServerNotification["LOG_MESSAGE"] = "window/logMessage";
    })(ServerNotification = Method.ServerNotification || (Method.ServerNotification = {}));
    /** Client notifications */
    let ClientNotification;
    (function (ClientNotification) {
        ClientNotification["DID_CHANGE"] = "textDocument/didChange";
        ClientNotification["DID_CHANGE_CONFIGURATION"] = "workspace/didChangeConfiguration";
        ClientNotification["DID_OPEN"] = "textDocument/didOpen";
        ClientNotification["DID_SAVE"] = "textDocument/didSave";
        ClientNotification["INITIALIZED"] = "initialized";
        ClientNotification["SET_TRACE"] = "$/setTrace";
    })(ClientNotification = Method.ClientNotification || (Method.ClientNotification = {}));
    /** Server requests */
    let ServerRequest;
    (function (ServerRequest) {
        ServerRequest["REGISTER_CAPABILITY"] = "client/registerCapability";
        ServerRequest["SHOW_MESSAGE_REQUEST"] = "window/showMessageRequest";
        ServerRequest["UNREGISTER_CAPABILITY"] = "client/unregisterCapability";
        ServerRequest["WORKSPACE_CONFIGURATION"] = "workspace/configuration";
    })(ServerRequest = Method.ServerRequest || (Method.ServerRequest = {}));
    /** Client requests */
    let ClientRequest;
    (function (ClientRequest) {
        ClientRequest["COMPLETION"] = "textDocument/completion";
        ClientRequest["COMPLETION_ITEM_RESOLVE"] = "completionItem/resolve";
        ClientRequest["DEFINITION"] = "textDocument/definition";
        ClientRequest["DOCUMENT_HIGHLIGHT"] = "textDocument/documentHighlight";
        ClientRequest["DOCUMENT_SYMBOL"] = "textDocument/documentSymbol";
        ClientRequest["HOVER"] = "textDocument/hover";
        ClientRequest["IMPLEMENTATION"] = "textDocument/implementation";
        ClientRequest["INITIALIZE"] = "initialize";
        ClientRequest["REFERENCES"] = "textDocument/references";
        ClientRequest["RENAME"] = "textDocument/rename";
        ClientRequest["SIGNATURE_HELP"] = "textDocument/signatureHelp";
        ClientRequest["TYPE_DEFINITION"] = "textDocument/typeDefinition";
    })(ClientRequest = Method.ClientRequest || (Method.ClientRequest = {}));
})(Method || (Method = {}));
class ClientRequestHandler {
    constructor(connection, method, emitter) {
        this.connection = connection;
        this.method = method;
        this.emitter = emitter;
    }
    request(params) {
        // TODO check if is ready?
        this.emitter.log(MessageKind.client_requested, {
            method: this.method,
            message: params
        });
        return this.connection
            .sendRequest(this.method, params)
            .then((result) => {
            this.emitter.log(MessageKind.result_for_client, {
                method: this.method,
                message: params
            });
            return result;
        });
    }
}
class ServerRequestHandler {
    constructor(connection, method, emitter) {
        this.connection = connection;
        this.method = method;
        this.emitter = emitter;
        // on request accepts "thenable"
        this.connection.onRequest(method, this.handle.bind(this));
        this._handler = null;
    }
    handle(request) {
        this.emitter.log(MessageKind.server_requested, {
            method: this.method,
            message: request
        });
        if (!this._handler) {
            return new Promise(() => undefined);
        }
        return this._handler(request, this.emitter).then(result => {
            this.emitter.log(MessageKind.response_for_server, {
                method: this.method,
                message: result
            });
            return result;
        });
    }
    setHandler(handler) {
        this._handler = handler;
    }
    clearHandler() {
        this._handler = null;
    }
}
export const Provider = {
    TEXT_DOCUMENT_SYNC: 'textDocumentSync',
    COMPLETION: 'completionProvider',
    HOVER: 'hoverProvider',
    SIGNATURE_HELP: 'signatureHelpProvider',
    DECLARATION: 'declarationProvider',
    DEFINITION: 'definitionProvider',
    TYPE_DEFINITION: 'typeDefinitionProvider',
    IMPLEMENTATION: 'implementationProvider',
    REFERENCES: 'referencesProvider',
    DOCUMENT_HIGHLIGHT: 'documentHighlightProvider',
    DOCUMENT_SYMBOL: 'documentSymbolProvider',
    CODE_ACTION: 'codeActionProvider',
    CODE_LENS: 'codeLensProvider',
    DOCUMENT_LINK: 'documentLinkProvider',
    COLOR: 'colorProvider',
    DOCUMENT_FORMATTING: 'documentFormattingProvider',
    DOCUMENT_RANGE_FORMATTING: 'documentRangeFormattingProvider',
    DOCUMENT_ON_TYPE_FORMATTING: 'documentOnTypeFormattingProvider',
    RENAME: 'renameProvider',
    FOLDING_RANGE: 'foldingRangeProvider',
    EXECUTE_COMMAND: 'executeCommandProvider',
    SELECTION_RANGE: 'selectionRangeProvider',
    WORKSPACE_SYMBOL: 'workspaceSymbolProvider',
    WORKSPACE: 'workspace'
};
function createMethodMap(methods, handlerFactory) {
    const result = {};
    for (let method of Object.values(methods)) {
        result[method] = handlerFactory(method);
    }
    return result;
}
var MessageKind;
(function (MessageKind) {
    MessageKind[MessageKind["client_notified_server"] = 0] = "client_notified_server";
    MessageKind[MessageKind["server_notified_client"] = 1] = "server_notified_client";
    MessageKind[MessageKind["server_requested"] = 2] = "server_requested";
    MessageKind[MessageKind["client_requested"] = 3] = "client_requested";
    MessageKind[MessageKind["result_for_client"] = 4] = "result_for_client";
    MessageKind[MessageKind["response_for_server"] = 5] = "response_for_server";
})(MessageKind || (MessageKind = {}));
export class LSPConnection extends LspWsConnection {
    constructor(options) {
        super(options);
        this.closing_manually = false;
        this._options = options;
        this.logAllCommunication = false;
        this.serverIdentifier = options.serverIdentifier;
        this.console = options.console.scope(this.serverIdentifier + ' connection');
        this.documentsToOpen = [];
        this.clientNotifications =
            this.constructNotificationHandlers(Method.ClientNotification);
        this.serverNotifications =
            this.constructNotificationHandlers(Method.ServerNotification);
    }
    log(kind, message) {
        if (this.logAllCommunication) {
            this.console.log(kind, message);
        }
    }
    constructNotificationHandlers(methods) {
        return createMethodMap(methods, () => new Signal(this));
    }
    constructClientRequestHandler(methods) {
        return createMethodMap(methods, method => new ClientRequestHandler(this.connection, method, this));
    }
    constructServerRequestHandler(methods) {
        return createMethodMap(methods, method => new ServerRequestHandler(this.connection, method, this));
    }
    /**
     * Initialization parameters to be sent to the language server.
     * Subclasses can overload this when adding more features.
     */
    initializeParams() {
        return Object.assign(Object.assign({}, super.initializeParams()), { 
            // TODO: remove as `lsp.ClientCapabilities` after upgrading to 3.17
            // which should finally include a fix for moniker issue:
            // https://github.com/microsoft/vscode-languageserver-node/pull/720
            capabilities: this._options.capabilities, initializationOptions: null, processId: null, workspaceFolders: null });
    }
    sendOpenWhenReady(documentInfo) {
        if (this.isReady) {
            this.sendOpen(documentInfo);
        }
        else {
            this.documentsToOpen.push(documentInfo);
        }
    }
    onServerInitialized(params) {
        this.afterInitialized();
        super.onServerInitialized(params);
        while (this.documentsToOpen.length) {
            this.sendOpen(this.documentsToOpen.pop());
        }
    }
    afterInitialized() {
        for (const method of Object.values(Method.ServerNotification)) {
            const signal = this.serverNotifications[method];
            this.connection.onNotification(method, params => {
                this.log(MessageKind.server_notified_client, {
                    method,
                    message: params
                });
                signal.emit(params);
            });
        }
        for (const method of Object.values(Method.ClientNotification)) {
            const signal = this.clientNotifications[method];
            signal.connect((emitter, params) => {
                this.log(MessageKind.client_notified_server, {
                    method,
                    message: params
                });
                this.connection.sendNotification(method, params);
            });
        }
        this.clientRequests = this.constructClientRequestHandler(Method.ClientRequest);
        this.serverRequests = this.constructServerRequestHandler(Method.ServerRequest);
        this.serverRequests['client/registerCapability'].setHandler(async (params) => {
            params.registrations.forEach((capabilityRegistration) => {
                try {
                    const updatedCapabilities = registerServerCapability(this.serverCapabilities, capabilityRegistration);
                    if (updatedCapabilities === null) {
                        this.console.error(`Failed to register server capability: ${capabilityRegistration}`);
                        return;
                    }
                    this.serverCapabilities = updatedCapabilities;
                }
                catch (err) {
                    this.console.error(err);
                }
            });
        });
        this.serverRequests['client/unregisterCapability'].setHandler(async (params) => {
            params.unregisterations.forEach((capabilityUnregistration) => {
                this.serverCapabilities = unregisterServerCapability(this.serverCapabilities, capabilityUnregistration);
            });
        });
        this.serverRequests['workspace/configuration'].setHandler(async (params) => {
            return params.items.map(item => {
                // LSP: "If the client canâ€™t provide a configuration setting for a given scope
                // then `null` needs to be present in the returned array."
                // for now we do not support configuration, but yaml server does not respect
                // client capability so we have a handler just for that
                return null;
            });
        });
    }
    sendSelectiveChange(changeEvent, documentInfo) {
        this._sendChange([changeEvent], documentInfo);
    }
    sendFullTextChange(text, documentInfo) {
        this._sendChange([{ text }], documentInfo);
    }
    /**
     * @deprecated The method should not be used in new code. Use provides() instead.
     */
    isRenameSupported() {
        return !!(this.serverCapabilities && this.serverCapabilities.renameProvider);
    }
    provides(provider) {
        return !!(this.serverCapabilities && this.serverCapabilities[provider]);
    }
    /**
     * @deprecated The method should not be used in new code
     */
    async rename(location, documentInfo, newName, emit = true) {
        if (!this.isReady || !this.isRenameSupported()) {
            return null;
        }
        const params = {
            textDocument: {
                uri: documentInfo.uri
            },
            position: {
                line: location.line,
                character: location.ch
            },
            newName
        };
        const edit = await this.connection.sendRequest('textDocument/rename', params);
        if (emit) {
            this.emit('renamed', edit);
        }
        return edit;
    }
    connect(socket) {
        super.connect(socket);
        until_ready(() => {
            return this.isConnected;
        }, -1)
            .then(() => {
            this.connection.onClose(() => {
                this.isConnected = false;
                this.emit('close', this.closing_manually);
            });
        })
            .catch(() => {
            console.error('Could not connect onClose signal');
        });
        return this;
    }
    close() {
        try {
            this.closing_manually = true;
            super.close();
        }
        catch (e) {
            this.closing_manually = false;
        }
    }
    _sendChange(changeEvents, documentInfo) {
        if (!this.isReady) {
            return;
        }
        if (!this.openedUris.get(documentInfo.uri)) {
            this.sendOpen(documentInfo);
        }
        const textDocumentChange = {
            textDocument: {
                uri: documentInfo.uri,
                version: documentInfo.version
            },
            contentChanges: changeEvents
        };
        this.connection.sendNotification('textDocument/didChange', textDocumentChange);
        documentInfo.version++;
    }
    async getCompletionResolve(completionItem) {
        if (!this.isReady || !this.isCompletionResolveProvider()) {
            return;
        }
        return this.connection.sendRequest('completionItem/resolve', completionItem);
    }
    /**
     * Does support completionItem/resolve?
     * @deprecated The method should not be used in new code
     */
    isCompletionResolveProvider() {
        var _a, _b;
        return (((_b = (_a = this.serverCapabilities) === null || _a === void 0 ? void 0 : _a.completionProvider) === null || _b === void 0 ? void 0 : _b.resolveProvider) || false);
    }
}
//# sourceMappingURL=connection.js.map