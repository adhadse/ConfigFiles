/** The Public API, as exposed in the `main` field of package.json */
/** General public tokens, including lumino Tokens and namespaces */
export * from './tokens';
/** Component- and feature-specific APIs */
export * from './api';
import { JupyterFrontEnd } from '@jupyterlab/application';
import { ICommandPalette } from '@jupyterlab/apputils';
import { IDocumentManager } from '@jupyterlab/docmanager';
import { ILoggerRegistry } from '@jupyterlab/logconsole';
import { ISettingRegistry } from '@jupyterlab/settingregistry';
import { IStatusBar } from '@jupyterlab/statusbar';
import { ITranslator, nullTranslator } from '@jupyterlab/translation';
import { COMPLETION_THEME_MANAGER } from '@krassowski/completion-theme';
import { plugin as THEME_MATERIAL } from '@krassowski/theme-material';
import { plugin as THEME_VSCODE } from '@krassowski/theme-vscode';
import { Signal } from '@lumino/signaling';
import '../style/index.css';
import { WIDGET_ADAPTER_MANAGER } from './adapter_manager';
import { FILE_EDITOR_ADAPTER } from './adapters/file_editor';
import { NOTEBOOK_ADAPTER } from './adapters/notebook';
import { ContextCommandManager } from './command_manager';
import { StatusButtonExtension } from './components/statusbar';
import { DocumentConnectionManager } from './connection_manager';
import { CODE_EXTRACTORS_MANAGER } from './extractors/manager';
import { COMPLETION_PLUGIN } from './features/completion';
import { DIAGNOSTICS_PLUGIN } from './features/diagnostics';
import { HIGHLIGHTS_PLUGIN } from './features/highlights';
import { HOVER_PLUGIN } from './features/hover';
import { JUMP_PLUGIN } from './features/jump_to';
import { RENAME_PLUGIN } from './features/rename';
import { SIGNATURE_PLUGIN } from './features/signature';
import { SYNTAX_HIGHLIGHTING_PLUGIN } from './features/syntax_highlighting';
import { LanguageServerManager } from './manager';
import { CODE_OVERRIDES_MANAGER } from './overrides';
import { ILSPCodeOverridesManager } from './overrides/tokens';
import { ILSPAdapterManager, ILSPCodeExtractorsManager, ILSPFeatureManager, ILSPLogConsole, ILSPVirtualEditorManager, PLUGIN_ID } from './tokens';
import { DEFAULT_TRANSCLUSIONS } from './transclusions/defaults';
import { CODEMIRROR_VIRTUAL_EDITOR } from './virtual/codemirror_editor';
import { LOG_CONSOLE } from './virtual/console';
import { VIRTUAL_EDITOR_MANAGER } from './virtual/editor';
var IPaths = JupyterFrontEnd.IPaths;
export class FeatureManager {
    constructor() {
        this.features = [];
        this.command_managers = [];
        this.command_manager_registered = new Signal(this);
    }
    _register(options) {
        if (options.supersedes) {
            for (let option of options.supersedes) {
                this.features = this.features.filter(feature => feature.id != option);
            }
        }
        this.features.push(options.feature);
        if (options.feature.commands) {
            for (let command_manager of this.command_managers) {
                command_manager.add(options.feature.commands);
            }
            this.command_manager_registered.connect((feature_manager, command_manager) => {
                if (options.feature.commands) {
                    command_manager.add(options.feature.commands);
                }
            });
        }
    }
    register(options) {
        if (options.feature.settings && options.feature.settings.ready) {
            options.feature.settings.ready
                .then(() => {
                var _a, _b;
                if (!((_b = (_a = options.feature) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b.composite.disable)) {
                    this._register(options);
                }
                else {
                    console.log('Skipping ', options.feature.id, 'as disabled');
                }
            })
                .catch(console.warn);
            return;
        }
        else {
            this._register(options);
        }
    }
    registerCommandManager(manager) {
        this.command_managers.push(manager);
        this.command_manager_registered.emit(manager);
    }
}
export class LSPExtension {
    constructor(app, setting_registry, palette, documentManager, paths, adapterManager, editor_type_manager, code_extractors_manager, code_overrides_manager, console, translator, user_console, status_bar) {
        this.app = app;
        this.setting_registry = setting_registry;
        this.palette = palette;
        this.editor_type_manager = editor_type_manager;
        this.code_extractors_manager = code_extractors_manager;
        this.code_overrides_manager = code_overrides_manager;
        this.console = console;
        this.translator = translator;
        this.user_console = user_console;
        const trans = (translator || nullTranslator).load('jupyterlab_lsp');
        this.language_server_manager = new LanguageServerManager({
            console: this.console.scope('LanguageServerManager')
        });
        this.connection_manager = new DocumentConnectionManager({
            language_server_manager: this.language_server_manager,
            console: this.console.scope('DocumentConnectionManager')
        });
        const statusButtonExtension = new StatusButtonExtension({
            language_server_manager: this.language_server_manager,
            connection_manager: this.connection_manager,
            adapter_manager: adapterManager,
            translator_bundle: trans
        });
        if (status_bar !== null) {
            status_bar.registerStatusItem(PLUGIN_ID + ':language-server-status', {
                item: statusButtonExtension.createItem(),
                align: 'left',
                rank: 1,
                isActive: () => adapterManager.isAnyActive()
            });
        }
        else {
            app.docRegistry.addWidgetExtension('Notebook', statusButtonExtension);
        }
        this.feature_manager = new FeatureManager();
        this.setting_registry
            .load(plugin.id)
            .then(settings => {
            const options = settings.composite;
            // Store the initial server settings, to be sent asynchronously
            // when the servers are initialized.
            const initial_configuration = (options.language_servers ||
                {});
            this.connection_manager.initial_configurations = initial_configuration;
            // update the server-independent part of configuration immediately
            this.connection_manager.updateConfiguration(initial_configuration);
            this.connection_manager.updateLogging(options.logAllCommunication, options.setTrace);
            settings.changed.connect(() => {
                this.updateOptions(settings);
            });
        })
            .catch((reason) => {
            console.error(reason.message);
        });
        adapterManager.registerExtension(this);
    }
    registerAdapterType(adapterManager, type) {
        let command_manger = new ContextCommandManager(Object.assign({ adapter_manager: adapterManager, app: this.app, palette: this.palette, tracker: type.tracker, suffix: type.name, entry_point: type.entrypoint, console: this.console }, type.context_menu));
        this.feature_manager.registerCommandManager(command_manger);
    }
    get foreign_code_extractors() {
        return this.code_extractors_manager.registry;
    }
    get code_overrides() {
        return this.code_overrides_manager.registry;
    }
    updateOptions(settings) {
        const options = settings.composite;
        const languageServerSettings = (options.language_servers ||
            {});
        this.connection_manager.initial_configurations = languageServerSettings;
        // TODO: if priorities changed reset connections
        this.connection_manager.updateConfiguration(languageServerSettings);
        this.connection_manager.updateServerConfigurations(languageServerSettings);
        this.connection_manager.updateLogging(options.logAllCommunication, options.setTrace);
    }
}
/**
 * The plugin registration information.
 */
const plugin = {
    id: PLUGIN_ID + ':plugin',
    requires: [
        ISettingRegistry,
        ICommandPalette,
        IDocumentManager,
        IPaths,
        ILSPAdapterManager,
        ILSPVirtualEditorManager,
        ILSPCodeExtractorsManager,
        ILSPCodeOverridesManager,
        ILSPLogConsole,
        ITranslator
    ],
    optional: [ILoggerRegistry, IStatusBar],
    activate: (app, ...args) => {
        let extension = new LSPExtension(app, ...args);
        return extension.feature_manager;
    },
    provides: ILSPFeatureManager,
    autoStart: true
};
const default_features = [
    JUMP_PLUGIN,
    COMPLETION_PLUGIN,
    SIGNATURE_PLUGIN,
    HOVER_PLUGIN,
    RENAME_PLUGIN,
    HIGHLIGHTS_PLUGIN,
    DIAGNOSTICS_PLUGIN,
    SYNTAX_HIGHLIGHTING_PLUGIN
];
const plugins = [
    LOG_CONSOLE,
    CODE_EXTRACTORS_MANAGER,
    WIDGET_ADAPTER_MANAGER,
    NOTEBOOK_ADAPTER,
    FILE_EDITOR_ADAPTER,
    VIRTUAL_EDITOR_MANAGER,
    CODEMIRROR_VIRTUAL_EDITOR,
    COMPLETION_THEME_MANAGER,
    THEME_VSCODE,
    THEME_MATERIAL,
    CODE_OVERRIDES_MANAGER,
    plugin,
    ...DEFAULT_TRANSCLUSIONS,
    ...default_features
];
/**
 * Export the plugins as default.
 */
export default plugins;
//# sourceMappingURL=index.js.map